<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Make crypto charts cute! Because charts shouldn't be ugly.">
<meta property="og:title" content="Cute Crypto Charts">
<meta property="og:description" content="Make crypto charts cute! Because charts shouldn't be ugly.">
<meta property="og:image" content="https://cutecryptocharts.com/og-image.png">
<meta property="og:url" content="https://cutecryptocharts.com">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Cute Crypto Charts">
<meta name="twitter:description" content="Make crypto charts cute! Because charts shouldn't be ugly.">
<meta name="twitter:image" content="https://cutecryptocharts.com/og-image.png">
<link rel="icon" type="image/png" href="favicon.png">
<link rel="apple-touch-icon" href="favicon.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bangers&family=Space+Mono:wght@400;700&family=Fredoka:wght@400;600&family=Bubblegum+Sans&family=Press+Start+2P&family=Righteous&family=Pacifico&family=Bungee&display=swap" rel="stylesheet">
<title>Cute Crypto Charts</title>
<style>
  :root {
    --color-text: #e0e0e0;
    --color-chart-bg: #16213e;
    --color-page-bg: #1a1a2e;
    --color-active-bg: #0f3460;
    --color-active-border: #4a7cbb;
    --font-family: 'Bangers', cursive;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--color-page-bg);
    color: var(--color-text);
    font-family: var(--font-family);
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    overflow: hidden;
  }
  .logo {
    position: absolute;
    top: 16px;
    left: 16px;
    height: 8vh;
  }
  .logo img {
    height: 100%;
    width: auto;
  }
  @media (max-width: 600px) {
    .logo {
      position: static;
      display: flex;
      justify-content: center;
      margin-bottom: 8px;
      height: 6vh;
    }
  }
  h1 { font-size: 1.5rem; margin-bottom: 8px; color: var(--color-text); flex-shrink: 0; }
  .subtitle { color: var(--color-text); opacity: 0.6; font-size: 0.85rem; margin-bottom: 8px; flex-shrink: 0; }
  .customize-panel {
    background: var(--color-chart-bg);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px;
    margin-bottom: 12px;
    flex-shrink: 0;
    overflow: hidden;
    width: 100%;
    max-width: 700px;
  }
  .customize-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 16px;
    cursor: pointer;
    user-select: none;
  }
  .customize-header span {
    font-size: 0.85rem;
    color: var(--color-text);
    opacity: 0.7;
    letter-spacing: 1px;
    text-transform: uppercase;
  }
  .customize-toggle {
    background: none;
    border: none;
    color: var(--color-text);
    opacity: 0.5;
    font-size: 1rem;
    cursor: pointer;
    transition: transform 0.2s;
    padding: 0 4px;
  }
  .customize-panel.collapsed .customize-toggle {
    transform: rotate(180deg);
  }
  .customize-panel.collapsed .controls {
    display: none;
  }
  .controls {
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
    padding: 0 16px 12px;
    flex-shrink: 0;
  }
  .emoji-picker {
    display: flex;
    align-items: center;
    gap: 6px;
    position: relative;
  }
  .emoji-picker label { font-size: 0.85rem; color: var(--color-text); opacity: 0.7; }
  .emoji-btn {
    width: 50px;
    height: 40px;
    font-size: 1.5rem;
    text-align: center;
    border: 1px solid #333;
    border-radius: 8px;
    background: var(--color-chart-bg);
    cursor: pointer;
    padding: 0;
    line-height: 40px;
  }
  .emoji-popup {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    z-index: 100;
    background: var(--color-chart-bg);
    border: 1px solid #444;
    border-radius: 10px;
    padding: 8px;
    width: 260px;
    max-height: 220px;
    overflow-y: auto;
    box-shadow: 0 8px 24px rgba(0,0,0,0.5);
  }
  .emoji-popup.open { display: flex; flex-wrap: wrap; gap: 2px; }
  @media (max-width: 600px) {
    .emoji-popup {
      position: fixed;
      top: auto;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      max-height: 50vh;
      border-radius: 16px 16px 0 0;
      padding: 16px;
      gap: 4px;
      justify-content: center;
    }
    .emoji-popup span {
      font-size: 1.6rem;
      width: 44px;
      height: 44px;
    }
  }
  .emoji-popup span {
    font-size: 1.3rem;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.15s;
  }
  .emoji-popup span:hover { background: rgba(255,255,255,0.1); }
  .color-picker {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .color-picker label { font-size: 0.75rem; color: var(--color-text); opacity: 0.7; }
  .color-picker select {
    height: 32px;
    border: 1px solid #333;
    border-radius: 6px;
    background: var(--color-chart-bg);
    color: var(--color-text);
    font-family: var(--font-family);
    font-size: 0.8rem;
    padding: 0 6px;
    cursor: pointer;
  }
  .color-picker input[type="color"] {
    width: 32px;
    height: 32px;
    border: 1px solid #333;
    border-radius: 6px;
    background: none;
    cursor: pointer;
    padding: 2px;
  }
  .bottom-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 1100px;
    padding: 8px 0;
    flex-shrink: 0;
  }
  .bottom-bar .subtitle {
    margin-bottom: 0;
  }
  .timeframe-btns {
    display: flex;
    gap: 6px;
  }
  .timeframe-btns button {
    padding: 8px 16px;
    border: 1px solid var(--color-text);
    border-radius: 8px;
    background: transparent;
    color: var(--color-text);
    cursor: pointer;
    font-size: 0.9rem;
    transition: background 0.2s, border-color 0.2s;
  }
  .timeframe-btns button:hover { background: rgba(255,255,255,0.05); }
  .timeframe-btns button.active {
    background: var(--color-active-bg);
    border-color: var(--color-active-border);
    color: var(--color-text);
  }
  .chart-container {
    width: 100%;
    max-width: 1100px;
    flex: 1;
    min-height: 0;
    background: var(--color-chart-bg);
    border-radius: 12px;
    padding: 20px;
    position: relative;
    display: flex;
    flex-direction: column;
  }
  .chart-grid {
    display: grid;
    grid-template-columns: 1fr 70px;
    grid-template-rows: 1fr 36px;
    flex: 1;
    min-height: 0;
  }
  .candles-scroll {
    grid-column: 1;
    grid-row: 1;
    overflow-x: auto;
    overflow-y: hidden;
    border-right: 1px solid #333;
    border-bottom: 1px solid #333;
  }
  .candles-area {
    display: flex;
    align-items: flex-end;
    gap: 2px;
    padding: 0 4px;
    min-width: max-content;
  }
  .y-axis {
    grid-column: 2;
    grid-row: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding-left: 10px;
    text-align: left;
    font-size: 0.75rem;
    color: var(--color-text);
    opacity: 0.6;
    border-bottom: 1px solid #333;
    position: relative;
  }
  .price-tag {
    position: absolute;
    left: 0;
    right: 0;
    transform: translateY(50%);
    font-size: 0.75rem;
    font-weight: bold;
    color: var(--color-page-bg);
    pointer-events: none;
    white-space: nowrap;
    z-index: 1;
  }
  .price-tag-label {
    background: var(--color-text);
    padding: 2px 8px;
    border-radius: 4px;
    line-height: 20px;
    display: block;
    text-align: left;
  }
  .x-axis-scroll {
    grid-column: 1;
    grid-row: 2;
    overflow: hidden;
    position: relative;
  }
  .x-axis {
    display: flex;
    gap: 2px;
    padding: 6px 4px 0 4px;
    min-width: max-content;
  }
  .x-label {
    font-size: 0.6rem;
    color: var(--color-text);
    opacity: 0.5;
    text-align: center;
    white-space: nowrap;
  }
  .chart-corner {
    grid-column: 2;
    grid-row: 2;
  }
  .candle-col {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 22px;
  }
  .candle-inner {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
  }
  .wick {
    width: 2px;
    background: #555;
  }
  .candle-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1;
  }
  .candle-body .emoji {
    font-size: 14px;
    line-height: 16px;
    height: 16px;
  }
  .x-label-cell {
    min-width: 22px;
    text-align: center;
    font-size: 0.6rem;
    color: var(--color-text);
    opacity: 0.5;
  }
  .loading {
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    color: var(--color-text);
    opacity: 0.6;
    font-size: 1rem;
  }
  .error { color: #e94560; }
</style>
</head>
<body>

<div class="logo">
  <img src="logo cute crypto.svg" alt="Cute Crypto Charts" style="filter: brightness(0) invert(1);">
</div>

<div class="customize-panel" id="customizePanel">
  <div class="customize-header" id="customizeHeader">
    <span>Customize</span>
    <button class="customize-toggle">â–²</button>
  </div>
  <div class="controls">
  <div class="emoji-picker" id="upPicker">
    <label>Up:</label>
    <button class="emoji-btn" id="upBtn">ðŸ˜Š</button>
    <div class="emoji-popup" id="upPopup"></div>
  </div>
  <div class="emoji-picker" id="downPicker">
    <label>Down:</label>
    <button class="emoji-btn" id="downBtn">ðŸ˜¡</button>
    <div class="emoji-popup" id="downPopup"></div>
  </div>
  <div class="color-picker">
    <label>Text</label>
    <input type="color" id="colorText" value="#e0e0e0">
  </div>
  <div class="color-picker">
    <label>Chart</label>
    <input type="color" id="colorChart" value="#16213e">
  </div>
  <div class="color-picker">
    <label>Page</label>
    <input type="color" id="colorPage" value="#1a1a2e">
  </div>
  <div class="color-picker">
    <label>Font</label>
    <select id="fontPicker">
      <option value="'Bangers', cursive" selected>Bangers</option>
      <option value="'Space Mono', monospace">Space Mono</option>
      <option value="Impact, sans-serif">Impact</option>
      <option value="'Comic Sans MS', 'Comic Sans', cursive">Comic Sans</option>
      <option value="'Fredoka', sans-serif">Fredoka</option>
      <option value="'Bubblegum Sans', cursive">Bubblegum Sans</option>
      <option value="'Press Start 2P', monospace">Press Start 2P</option>
      <option value="'Righteous', sans-serif">Righteous</option>
      <option value="'Pacifico', cursive">Pacifico</option>
      <option value="'Bungee', sans-serif">Bungee</option>
    </select>
  </div>
  </div>
</div>

<div class="chart-container">
  <div id="chart" class="loading">Loading...</div>
</div>
<div class="bottom-bar">
  <div class="timeframe-btns">
    <button class="active" data-interval="1m">1m</button>
    <button data-interval="30m">30m</button>
    <button data-interval="1d">1d</button>
  </div>
  <p class="subtitle" id="sourceLabel">SOL / USDT &mdash; Binance</p>
</div>

<script>
const SYMBOL = 'SOLUSDT';
const LIMIT = 50;
const EMOJI_HEIGHT = 16;
const Y_TICKS = 8;

let currentInterval = '1m';
let upEmoji = 'ðŸ˜Š';
let downEmoji = 'ðŸ˜¡';

const chartEl = document.getElementById('chart');

// --- Emoji Picker ---
const EMOJI_LIST = [
  'ðŸ˜Š','ðŸ˜‚','ðŸ¤£','ðŸ˜','ðŸ˜Ž','ðŸ¥³','ðŸ¤©','ðŸ˜‡','ðŸ¥°','ðŸ˜',
  'ðŸ˜¡','ðŸ¤¬','ðŸ˜¤','ðŸ‘¿','ðŸ’€','â˜ ï¸','ðŸ”¥','ðŸ’¥','ðŸ’¢','ðŸ˜ˆ',
  'ðŸš€','ðŸ“ˆ','ðŸ“‰','ðŸ’°','ðŸ’¸','ðŸ¤‘','ðŸ’Ž','ðŸ†','â­','ðŸŒŸ',
  'â¤ï¸','ðŸ’š','ðŸ’›','ðŸ’œ','ðŸ–¤','ðŸ¤','ðŸ’™','ðŸ§¡','â£ï¸','ðŸ’—',
  'ðŸ‘','ðŸ‘Ž','ðŸ‘†','ðŸ‘‡','âœŒï¸','ðŸ¤ž','ðŸ«¡','ðŸ’ª','ðŸ‘','ðŸ™Œ',
  'ðŸ‚','ðŸ»','ðŸ¦','ðŸ¸','ðŸµ','ðŸ¦„','ðŸ','ðŸ¦…','ðŸ³','ðŸ”',
  'âœ…','âŒ','âš¡','ðŸ’¡','ðŸŽ¯','ðŸŽ²','ðŸŽ°','ðŸª™','ðŸ“Š','ðŸ§²',
];

function populatePopup(popupEl, onSelect) {
  popupEl.innerHTML = '';
  EMOJI_LIST.forEach(e => {
    const span = document.createElement('span');
    span.textContent = e;
    span.addEventListener('click', (ev) => {
      ev.stopPropagation();
      onSelect(e);
      popupEl.classList.remove('open');
    });
    popupEl.appendChild(span);
  });
}

function setupEmojiPicker(btnId, popupId, initial, onSelect) {
  const btn = document.getElementById(btnId);
  const popup = document.getElementById(popupId);
  populatePopup(popup, (emoji) => {
    btn.textContent = emoji;
    onSelect(emoji);
    renderChart();
  });
  btn.addEventListener('click', (ev) => {
    ev.stopPropagation();
    // Close any other open popups
    document.querySelectorAll('.emoji-popup.open').forEach(p => {
      if (p !== popup) p.classList.remove('open');
    });
    popup.classList.toggle('open');
  });
}

setupEmojiPicker('upBtn', 'upPopup', upEmoji, v => upEmoji = v);
setupEmojiPicker('downBtn', 'downPopup', downEmoji, v => downEmoji = v);

// Close popups on outside click
document.addEventListener('click', () => {
  document.querySelectorAll('.emoji-popup.open').forEach(p => p.classList.remove('open'));
});

// --- Color Helpers ---
function hexToHsl(hex) {
  let r = parseInt(hex.slice(1,3),16)/255;
  let g = parseInt(hex.slice(3,5),16)/255;
  let b = parseInt(hex.slice(5,7),16)/255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  let h, s, l = (max+min)/2;
  if (max === min) { h = s = 0; }
  else {
    const d = max - min;
    s = l > 0.5 ? d/(2-max-min) : d/(max+min);
    if (max === r) h = ((g-b)/d + (g<b?6:0))/6;
    else if (max === g) h = ((b-r)/d+2)/6;
    else h = ((r-g)/d+4)/6;
  }
  return [h*360, s*100, l*100];
}

function hslToHex(h, s, l) {
  s /= 100; l /= 100;
  const a = s * Math.min(l, 1-l);
  const f = n => { const k = (n + h/30) % 12; return l - a * Math.max(Math.min(k-3, 9-k, 1), -1); };
  return '#' + [f(0),f(8),f(4)].map(x => Math.round(x*255).toString(16).padStart(2,'0')).join('');
}

function updateActiveColors(chartHex) {
  const [h, s, l] = hexToHsl(chartHex);
  // Active bg: shift lightness away from chart bg
  const activeBgL = l < 50 ? Math.min(l + 15, 90) : Math.max(l - 15, 10);
  // Active border: more saturated, shifted further in lightness
  const borderL = l < 50 ? Math.min(l + 30, 85) : Math.max(l - 30, 15);
  const borderS = Math.min(s + 20, 100);
  document.documentElement.style.setProperty('--color-active-bg', hslToHex(h, s, activeBgL));
  document.documentElement.style.setProperty('--color-active-border', hslToHex(h, borderS, borderL));
}

// --- Auto Text Color ---
function luminance(hex) {
  const r = parseInt(hex.slice(1,3),16)/255;
  const g = parseInt(hex.slice(3,5),16)/255;
  const b = parseInt(hex.slice(5,7),16)/255;
  // Relative luminance (WCAG)
  const toLinear = c => c <= 0.03928 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4);
  return 0.2126*toLinear(r) + 0.7152*toLinear(g) + 0.0722*toLinear(b);
}

function updateTextColor(pageBg, chartBg) {
  // Average luminance of both backgrounds
  const avg = (luminance(pageBg) + luminance(chartBg)) / 2;
  const textColor = avg < 0.4 ? '#e0e0e0' : '#1a1a1a';
  document.documentElement.style.setProperty('--color-text', textColor);
}

// --- Random Color Generation ---
function randomHex() {
  return '#' + Array.from({length: 3}, () =>
    Math.floor(Math.random()*256).toString(16).padStart(2,'0')
  ).join('');
}

function randomize() {
  // Random emojis (pick two different ones)
  const i1 = Math.floor(Math.random() * EMOJI_LIST.length);
  let i2 = Math.floor(Math.random() * EMOJI_LIST.length);
  while (i2 === i1) i2 = Math.floor(Math.random() * EMOJI_LIST.length);
  upEmoji = EMOJI_LIST[i1];
  downEmoji = EMOJI_LIST[i2];
  document.getElementById('upBtn').textContent = upEmoji;
  document.getElementById('downBtn').textContent = downEmoji;

  // Random colors
  const pageBg = randomHex();
  const chartBg = randomHex();
  document.documentElement.style.setProperty('--color-page-bg', pageBg);
  document.documentElement.style.setProperty('--color-chart-bg', chartBg);
  document.getElementById('colorPage').value = pageBg;
  document.getElementById('colorChart').value = chartBg;
  updateActiveColors(chartBg);
  // Auto pick text color for contrast
  updateTextColor(pageBg, chartBg);
  const textColor = getComputedStyle(document.documentElement).getPropertyValue('--color-text').trim();
  document.getElementById('colorText').value = textColor;
}

// Randomize on load
randomize();

// --- Color Pickers ---
const colorTextInput = document.getElementById('colorText');
const colorChartInput = document.getElementById('colorChart');
const colorPageInput = document.getElementById('colorPage');

colorTextInput.addEventListener('input', e => {
  document.documentElement.style.setProperty('--color-text', e.target.value);
});
colorChartInput.addEventListener('input', e => {
  document.documentElement.style.setProperty('--color-chart-bg', e.target.value);
  updateActiveColors(e.target.value);
});
colorPageInput.addEventListener('input', e => {
  document.documentElement.style.setProperty('--color-page-bg', e.target.value);
});

// --- Font Picker ---
document.getElementById('fontPicker').addEventListener('change', e => {
  document.documentElement.style.setProperty('--font-family', e.target.value);
});

// --- Timeframe buttons ---
document.querySelectorAll('.timeframe-btns button').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelector('.timeframe-btns .active').classList.remove('active');
    btn.classList.add('active');
    currentInterval = btn.dataset.interval;
    closeWebSocket();
    fetchAndRender();
  });
});

// --- Chart ---
let candles = [];
let dataSource = 'Binance';

function updateSourceLabel() {
  document.getElementById('sourceLabel').textContent = `SOL / USDT â€” ${dataSource}`;
}

// Binance interval -> Kraken interval (minutes)
const KRAKEN_INTERVALS = { '1m': 1, '30m': 30, '1d': 1440 };

async function fetchFromBinance() {
  const url = `https://api.binance.com/api/v3/klines?symbol=${SYMBOL}&interval=${currentInterval}&limit=${LIMIT}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Binance API error: ${res.status}`);
  const data = await res.json();
  return data.map(k => ({
    time: k[0],
    open: parseFloat(k[1]),
    high: parseFloat(k[2]),
    low: parseFloat(k[3]),
    close: parseFloat(k[4]),
  }));
}

async function fetchFromKraken() {
  const interval = KRAKEN_INTERVALS[currentInterval];
  const url = `https://api.kraken.com/0/public/OHLC?pair=SOLUSDT&interval=${interval}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Kraken API error: ${res.status}`);
  const data = await res.json();
  if (data.error && data.error.length) throw new Error(data.error[0]);
  const key = Object.keys(data.result).find(k => k !== 'last');
  const rows = data.result[key];
  // Kraken returns: [time, open, high, low, close, vwap, volume, count]
  // Take last LIMIT entries
  return rows.slice(-LIMIT).map(k => ({
    time: k[0] * 1000,
    open: parseFloat(k[1]),
    high: parseFloat(k[2]),
    low: parseFloat(k[3]),
    close: parseFloat(k[4]),
  }));
}

async function fetchCandles() {
  try {
    const result = await fetchFromBinance();
    dataSource = 'Binance';
    updateSourceLabel();
    return result;
  } catch (e) {
    const result = await fetchFromKraken();
    dataSource = 'Kraken';
    updateSourceLabel();
    return result;
  }
}

function formatTime(ts) {
  const d = new Date(ts);
  if (currentInterval === '1d') {
    return `${d.getMonth()+1}/${d.getDate()}`;
  }
  return `${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`;
}

function shouldShowLabel(ts, idx) {
  const d = new Date(ts);
  if (currentInterval === '1m') {
    return d.getMinutes() % 5 === 0;
  } else if (currentInterval === '30m') {
    return d.getMinutes() === 0;
  } else {
    return idx % 5 === 0;
  }
}

function renderChart() {
  if (!candles.length) return;

  // Dynamic chart height based on available space
  const container = document.querySelector('.chart-container');
  const CHART_HEIGHT = Math.max(200, container.clientHeight - 80);

  const allHighs = candles.map(c => c.high);
  const allLows = candles.map(c => c.low);
  const rawMax = Math.max(...allHighs);
  const rawMin = Math.min(...allLows);
  const rawRange = rawMax - rawMin || 1;
  // Add 20% padding above and below so candles sit centered
  const padding = rawRange * 0.2;
  const priceMax = rawMax + padding;
  const priceLow = rawMin - padding;
  const priceRange = priceMax - priceLow;

  const priceToPx = (p) => ((p - priceLow) / priceRange) * CHART_HEIGHT;

  const bodySizes = candles.map(c => Math.abs(c.close - c.open));
  // Use median body size for scaling so outliers don't shrink everything
  const sortedBodies = [...bodySizes].sort((a, b) => a - b);
  const medianBody = sortedBodies[Math.floor(sortedBodies.length / 2)] || 1;
  const maxBody = Math.max(medianBody * 3, Math.max(...bodySizes) || 1);
  const MIN_EMOJIS = currentInterval === '1m' ? 3 : 1;
  const MAX_EMOJIS = 10;

  // Y-axis labels snapped to 0.1 intervals
  const tickStart = Math.ceil(priceLow * 10) / 10;
  const tickEnd = Math.floor(priceMax * 10) / 10;
  const tickStep = Math.max(0.1, Math.round(((tickEnd - tickStart) / (Y_TICKS - 1)) * 10) / 10);
  let yAxisHtml = '';
  for (let p = tickEnd; p >= tickStart - 0.001; p -= tickStep) {
    yAxisHtml += `<div>${p.toFixed(1)}</div>`;
  }

  let candlesHtml = '';
  let xAxisHtml = '';
  candles.forEach((c, idx) => {
    const isUp = c.close >= c.open;
    const emoji = isUp ? upEmoji : downEmoji;
    const bodySize = Math.abs(c.close - c.open);
    const emojiCount = Math.max(MIN_EMOJIS, Math.round((bodySize / maxBody) * MAX_EMOJIS));

    const bodyTop = priceToPx(Math.max(c.open, c.close));
    const bodyBottom = priceToPx(Math.min(c.open, c.close));
    const highPx = priceToPx(c.high);
    const lowPx = priceToPx(c.low);

    const upperWick = highPx - bodyTop;
    const lowerWick = bodyBottom - lowPx;
    const bottomOffset = lowPx;

    let emojis = '';
    for (let i = 0; i < emojiCount; i++) {
      emojis += `<span class="emoji">${emoji}</span>`;
    }

    candlesHtml += `
      <div class="candle-col">
        <div class="candle-inner" style="margin-bottom:${bottomOffset}px;">
          <div class="wick" style="height:${Math.max(0, upperWick)}px;"></div>
          <div class="candle-body">${emojis}</div>
          <div class="wick" style="height:${Math.max(0, lowerWick)}px;"></div>
        </div>
      </div>`;

    const showLabel = shouldShowLabel(c.time, idx);
    xAxisHtml += `<div class="x-label-cell" style="min-width:22px;">${showLabel ? formatTime(c.time) : ''}</div>`;
  });

  const currentPrice = candles[candles.length - 1].close;

  chartEl.className = 'chart-grid';
  chartEl.innerHTML = `
    <div class="candles-scroll" id="candlesScroll">
      <div class="candles-area" style="height:${CHART_HEIGHT}px;">${candlesHtml}</div>
    </div>
    <div class="y-axis" style="height:${CHART_HEIGHT}px;">
      ${yAxisHtml}
      <div class="price-tag" style="bottom:${priceToPx(currentPrice)}px;"><div class="price-tag-label">${currentPrice.toFixed(2)}</div></div>
    </div>
    <div class="x-axis-scroll" id="xAxisScroll">
      <div class="x-axis">${xAxisHtml}</div>
    </div>
    <div class="chart-corner"></div>`;

  const candlesScroll = document.getElementById('candlesScroll');
  const xAxisScroll = document.getElementById('xAxisScroll');
  candlesScroll.scrollLeft = candlesScroll.scrollWidth;
  xAxisScroll.scrollLeft = candlesScroll.scrollLeft;

  candlesScroll.addEventListener('scroll', () => {
    xAxisScroll.scrollLeft = candlesScroll.scrollLeft;
  });
}

// --- WebSocket for 1m real-time ---
let ws = null;

function closeWebSocket() {
  if (ws) {
    ws.onclose = null;
    ws.close();
    ws = null;
  }
}

function connectBinanceWs() {
  return new Promise((resolve, reject) => {
    const sock = new WebSocket('wss://stream.binance.com:9443/ws/solusdt@kline_1m');
    const timeout = setTimeout(() => { sock.close(); reject(new Error('timeout')); }, 5000);
    sock.onopen = () => { clearTimeout(timeout); resolve(sock); };
    sock.onerror = () => { clearTimeout(timeout); reject(new Error('binance ws failed')); };
  });
}

function connectKrakenWs() {
  return new Promise((resolve, reject) => {
    const sock = new WebSocket('wss://ws.kraken.com/v2');
    const timeout = setTimeout(() => { sock.close(); reject(new Error('timeout')); }, 5000);
    sock.onopen = () => {
      clearTimeout(timeout);
      sock.send(JSON.stringify({
        method: 'subscribe',
        params: { channel: 'ohlc', symbol: ['SOL/USDT'], interval: 1 }
      }));
      resolve(sock);
    };
    sock.onerror = () => { clearTimeout(timeout); reject(new Error('kraken ws failed')); };
  });
}

function handleBinanceMessage(evt) {
  const msg = JSON.parse(evt.data);
  if (!msg.k) return;
  const k = msg.k;
  // k.t is the candle open time (start of the minute)
  applyRealtimeCandle({
    time: k.t,
    open: parseFloat(k.o),
    high: parseFloat(k.h),
    low: parseFloat(k.l),
    close: parseFloat(k.c),
  });
}

function handleKrakenMessage(evt) {
  const msg = JSON.parse(evt.data);
  if (msg.channel !== 'ohlc' || !msg.data || !msg.data.length) return;
  const k = msg.data[0];
  // Kraken timestamp is end of interval; floor to minute start
  const ts = new Date(k.timestamp).getTime();
  const minuteStart = Math.floor(ts / 60000) * 60000;
  applyRealtimeCandle({
    time: minuteStart,
    open: parseFloat(k.open),
    high: parseFloat(k.high),
    low: parseFloat(k.low),
    close: parseFloat(k.close),
  });
}

function applyRealtimeCandle(updatedCandle) {
  if (!candles.length) return;
  const last = candles[candles.length - 1];
  const lastMinute = Math.floor(last.time / 60000);
  const updMinute = Math.floor(updatedCandle.time / 60000);

  if (updMinute === lastMinute) {
    // Update current candle in place
    candles[candles.length - 1] = updatedCandle;
  } else if (updMinute > lastMinute) {
    // New minute â€” add new candle, drop oldest
    candles.push(updatedCandle);
    if (candles.length > LIMIT) candles.shift();
  }
  renderChart();
}

async function startWebSocket() {
  closeWebSocket();
  if (currentInterval !== '1m') return;

  try {
    ws = await connectBinanceWs();
    ws.onmessage = handleBinanceMessage;
    ws.onclose = () => { setTimeout(startWebSocket, 3000); };
    dataSource = 'Binance';
    updateSourceLabel();
  } catch (e) {
    try {
      ws = await connectKrakenWs();
      ws.onmessage = handleKrakenMessage;
      ws.onclose = () => { setTimeout(startWebSocket, 3000); };
      dataSource = 'Kraken';
      updateSourceLabel();
    } catch (e2) {
      // Both failed â€” retry after a delay
      setTimeout(startWebSocket, 5000);
    }
  }
}

async function fetchAndRender() {
  chartEl.className = 'loading';
  chartEl.innerHTML = 'Loading...';
  try {
    candles = await fetchCandles();
    renderChart();
    startWebSocket();
  } catch (e) {
    chartEl.className = 'loading';
    chartEl.innerHTML = `<span class="error">Failed to load data: ${e.message}</span>`;
  }
}

fetchAndRender();
</script>
</body>
</html>
